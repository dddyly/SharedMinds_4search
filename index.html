<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Immersive Sphere Search</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      background: #000000;
      color: #ffffff;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding: clamp(24px, 5vw, 48px);
      position: relative;
      overflow: hidden;
    }

    #sphere-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 0;
    }

    .bar {
      position: relative;
      z-index: 1;
      width: min(960px, 100%);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: clamp(12px, 2vw, 24px);
      justify-content: center;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-size: clamp(0.74rem, 1.8vw, 0.9rem);
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.35);
      border-radius: 999px;
      padding: 12px clamp(16px, 4vw, 32px);
    }

    h1 {
      margin: 0;
      font-size: 0.9em;
      font-weight: 600;
      white-space: nowrap;
    }

    form {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: clamp(10px, 2vw, 18px);
    }

    label {
      font-size: 0.72em;
      color: rgba(255, 255, 255, 0.65);
      white-space: nowrap;
    }

    input {
      padding: 10px 14px;
      font-size: 0.9em;
      font-variant-numeric: tabular-nums;
      color: #ffffff;
      background: #0f0f0f;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 8px;
      transition: border-color 160ms ease;
      min-width: 160px;
    }

    input:focus {
      outline: none;
      border-color: #ffffff;
    }

    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    button {
      padding: 11px 24px;
      font-size: 0.82em;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #000000;
      background: #ffffff;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 160ms ease, opacity 160ms ease;
    }

    button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
  <canvas id="sphere-canvas"></canvas>

  <div class="bar">
    <h1>Spherical Search</h1>
    <form id="search-form">
      <label for="query-input">Keywords</label>
      <input
        id="query-input"
        name="query"
        type="text"
        placeholder="e.g. generative art"
        required
        autocomplete="off"
      />
      <label for="layer-input">Layers</label>
      <input
        id="layer-input"
        name="layers"
        type="number"
        min="1"
        max="12"
        value="3"
        step="1"
        required
      />
      <button type="submit">Generate</button>
    </form>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    const canvas = document.getElementById('sphere-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      150
    );
    camera.position.set(0, 0, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 2;
    controls.maxDistance = 18;
    controls.autoRotate = false;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0x62d5ff, 0.75);
    keyLight.position.set(3, 5, 7);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xff6ec7, 0.4);
    rimLight.position.set(-4, -3, -6);
    scene.add(rimLight);

    const nodeGroup = new THREE.Group();
    scene.add(nodeGroup);

    const nodeGeometry = new THREE.SphereGeometry(0.12, 20, 20);
    const coreGeometry = new THREE.SphereGeometry(0.28, 32, 32);
    const layerPalette = [
      0x62d5ff,
      0xff9bf1,
      0x9effa9,
      0xffd36f,
      0xff6f91,
      0x7a9bff,
    ].map((hex) => new THREE.Color(hex));

    function clearGroup(group) {
      for (let i = group.children.length - 1; i >= 0; i -= 1) {
        group.remove(group.children[i]);
      }
    }

    function createLayerMaterial(layerIndex) {
      const color = layerPalette[layerIndex % layerPalette.length];
      return new THREE.MeshStandardMaterial({
        color,
        emissive: color.clone().multiplyScalar(0.1),
        roughness: 0.35,
        metalness: 0.1,
      });
    }

    function distributeOnSphere(count) {
      const points = [];
      const offset = 2 / count;
      const increment = Math.PI * (3 - Math.sqrt(5));
      for (let i = 0; i < count; i += 1) {
        const y = ((i * offset) - 1) + offset / 2;
        const r = Math.sqrt(Math.max(0, 1 - y * y));
        const phi = i * increment;
        const x = Math.cos(phi) * r;
        const z = Math.sin(phi) * r;
        points.push(new THREE.Vector3(x, y, z));
      }
      return points;
    }

    function populateMockSphere({ query, layers }) {
      clearGroup(nodeGroup);

      const coreMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: new THREE.Color(0x62d5ff).multiplyScalar(0.2),
        roughness: 0.4,
        metalness: 0.1,
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      core.userData = { type: 'core', label: query };
      nodeGroup.add(core);

      for (let layer = 1; layer <= layers; layer += 1) {
        const radius = 1.2 + layer * 0.9;
        const count = Math.round(14 + layer * 6);
        const positions = distributeOnSphere(count);
        const material = createLayerMaterial(layer - 1);

        for (const position of positions) {
          const node = new THREE.Mesh(nodeGeometry, material);
          node.position.copy(position.multiplyScalar(radius));
          node.scale.setScalar(0.6 + (layers - layer) * 0.06);
          node.userData = {
            type: 'result',
            layer,
            // Placeholder metadata for future use
            title: `Layer ${layer} node`;
          };
          nodeGroup.add(node);
        }
      }
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();
      nodeGroup.rotation.y = elapsed * 0.05;
      nodeGroup.rotation.x = Math.sin(elapsed * 0.1) * 0.02;
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    function handleResize() {
      const { innerWidth, innerHeight } = window;
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    window.addEventListener('resize', handleResize);

    const sceneManager = {
      update({ query, layers }) {
        populateMockSphere({ query, layers });
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.6;
      },
    };

    const form = document.getElementById('search-form');
    const queryInput = document.getElementById('query-input');
    const layerInput = document.getElementById('layer-input');

    form.addEventListener('submit', (event) => {
      event.preventDefault();

      const query = queryInput.value.trim();
      const layers = Number.parseInt(layerInput.value, 10);

      if (!query || Number.isNaN(layers)) {
        return;
      }

      sceneManager.update({ query, layers });
    });

    // Seed the scene once with defaults so the user lands in a populated view.
    sceneManager.update({ query: queryInput.value.trim() || 'explore', layers: Number(layerInput.value) });
  </script>
</body>
</html>
